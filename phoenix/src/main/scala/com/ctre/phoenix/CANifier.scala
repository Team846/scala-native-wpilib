package com.ctre.phoenix

import edu.wpi.first.wpilibj.hal.HAL

/**
  * CTRE CANifier
  *
  * Device for interfacing common devices to the CAN bus.
  *
  * Constructor.
  * @param deviceId	The CAN Device ID of the CANifier.
  */
class CANifier(deviceId: Int) {
  import CANifier._

  private var m_handle: Long = CANifierJNI.JNI_new_CANifier(deviceId)

  val PWMChannelCount: Int = 4

  private var _tempPins: Array[Boolean] = new Array[Boolean](11)

  HAL.report(63, deviceId + 1)

  /**
    * Sets the LED Output
    * @param percentOutput Output duty cycle expressed as percentage.
    * @param ledChannel 		Channel to set the output of.
    */
  def setLEDOutput(_percentOutput: Double, ledChannel: LEDChannel): Unit = {
    var percentOutput = _percentOutput

    /* convert float to integral fixed pt */
    if (percentOutput > 1) {
      percentOutput = 1
    }
    if (percentOutput < 0) {
      percentOutput = 0
    }
    val dutyCycle: Int = (percentOutput * 1023).toInt

    CANifierJNI.JNI_SetLEDOutput(m_handle, dutyCycle, ledChannel.value)
  }

  /**
    * Sets the output of a General Pin
    * @param outputPin 		The pin to use as output.
    * @param outputValue 	The desired output state.
    * @param outputEnable	Whether this pin is an output. "True" enables output.
    */
  def setGeneralOutput(outputPin: GeneralPin,
                       outputValue: Boolean,
                       outputEnable: Boolean): Unit = {
    CANifierJNI.JNI_SetGeneralOutput(m_handle,
      outputPin.value,
      outputValue,
      outputEnable)
  }

  /**
    * Sets the output of all General Pins
    * @param outputBits 	A bit mask of all the output states.  LSB->MSB is in the order of the #GeneralPin enum.
    * @param isOutputBits A boolean bit mask that sets the pins to be outputs or inputs.  A bit of 1 enables output.
    */
  def setGeneralOutputs(outputBits: Int, isOutputBits: Int): Unit = {
    CANifierJNI.JNI_SetGeneralOutputs(m_handle, outputBits, isOutputBits)
  }

  /**
    * Gets the state of all General Pins
    * @param allPins A structure to fill with the current state of all pins.
    */
  def getGeneralInputs(allPins: PinValues): Unit = {
    CANifierJNI.JNI_GetGeneralInputs(m_handle, _tempPins)
    allPins.LIMF = _tempPins(GeneralPin.LIMF.value)
    allPins.LIMR = _tempPins(GeneralPin.LIMR.value)
    allPins.QUAD_A = _tempPins(GeneralPin.QUAD_A.value)
    allPins.QUAD_B = _tempPins(GeneralPin.QUAD_B.value)
    allPins.QUAD_IDX = _tempPins(GeneralPin.QUAD_IDX.value)
    allPins.SCL = _tempPins(GeneralPin.SCL.value)
    allPins.SDA = _tempPins(GeneralPin.SDA.value)
    allPins.SPI_CLK_PWM0 = _tempPins(GeneralPin.SPI_CLK_PWM0P.value)
    allPins.SPI_MOSI_PWM1 = _tempPins(GeneralPin.SPI_MOSI_PWM1P.value)
    allPins.SPI_MISO_PWM2 = _tempPins(GeneralPin.SPI_MISO_PWM2P.value)
    allPins.SPI_CS_PWM3 = _tempPins(GeneralPin.SPI_CS.value)
  }

  /**
    * Gets the state of the specified pin
    * @param inputPin  The index of the pin.
    * @return The state of the pin.
    */
  def getGeneralInput(inputPin: GeneralPin): Boolean =
    CANifierJNI.JNI_GetGeneralInput(m_handle, inputPin.value)

  /**
    * Call GetLastError() generated by this object.
    * Not all functions return an error code but can
    * potentially report errors.
    *
    * This function can be used to retrieve those error codes.
    *
    * @return The last ErrorCode generated.
    */
  def getLastError(): ErrorCode = {
    val retval: Int = CANifierJNI.JNI_GetLastError(m_handle)
    ErrorCode.valueOf(retval)
  }

  /**
    * Sets the PWM Output
    * Currently supports PWM 0, PWM 1, and PWM 2
    * @param pwmChannel  Index of the PWM channel to output.
    * @param dutyCycle   Duty Cycle (0 to 1) to output.  Default period of the signal is 4.2 ms.
    */
  def setPWMOutput(_pwmChannel: Int, _dutyCycle: Double): Unit = {
    var pwmChannel = _pwmChannel
    var dutyCycle = _dutyCycle

    if (dutyCycle < 0) {
      dutyCycle = 0
    } else if (dutyCycle > 1) {
      dutyCycle = 1
    }
    if (pwmChannel < 0) {
      pwmChannel = 0
    }
    val dutyCyc10bit: Int = (1023 * dutyCycle).toInt
    CANifierJNI.JNI_SetPWMOutput(m_handle, pwmChannel.toInt, dutyCyc10bit)
  }

  /**
    * Enables PWM Outputs
    * Currently supports PWM 0, PWM 1, and PWM 2
    * @param pwmChannel  Index of the PWM channel to enable.
    * @param bEnable			"True" enables output on the pwm channel.
    */
  def enablePWMOutput(_pwmChannel: Int, bEnable: Boolean): Unit = {
    var pwmChannel = _pwmChannel

    if (pwmChannel < 0) {
      pwmChannel = 0
    }
    CANifierJNI.JNI_EnablePWMOutput(m_handle, pwmChannel.toInt, bEnable)
  }

  /**
    * Gets the PWM Input
    * @param pwmChannel  PWM channel to get.
    * @param dutyCycleAndPeriod	Double array to hold Duty Cycle [0] and Period [1].
    */
  def getPWMInput(pwmChannel: PWMChannel,
                  dutyCycleAndPeriod: Array[Double]): Unit = {
    CANifierJNI.JNI_GetPWMInput(m_handle, pwmChannel.value, dutyCycleAndPeriod)
  }

  /**
    * Sets the value of a custom parameter. This is for arbitrary use.
    *
    * Sometimes it is necessary to save calibration/duty cycle/output
    * information in the device. Particularly if the
    * device is part of a subsystem that can be replaced.
    *
    * @param newValue
    *            Value for custom parameter.
    * @param paramIndex
    *            Index of custom parameter. [0-1]
    * @param timeoutMs
    *            Timeout value in ms. If nonzero, function will wait for
    *            config success and report an error if it times out.
    *            If zero, no blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def configSetCustomParam(newValue: Int,
                           paramIndex: Int,
                           timeoutMs: Int): ErrorCode = {
    val retval: Int = CANifierJNI.JNI_ConfigSetCustomParam(m_handle,
      newValue,
      paramIndex,
      timeoutMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Gets the value of a custom parameter. This is for arbitrary use.
    *
    * Sometimes it is necessary to save calibration/duty cycle/output
    * information in the device. Particularly if the
    * device is part of a subsystem that can be replaced.
    *
    * @param paramIndex
    *            Index of custom parameter. [0-1]
    * @param timoutMs
    *            Timeout value in ms. If nonzero, function will wait for
    *            config success and report an error if it times out.
    *            If zero, no blocking or checking is performed.
    * @return Value of the custom param.
    */
  def configGetCustomParam(paramIndex: Int, timoutMs: Int): Int = {
    val retval: Int =
      CANifierJNI.JNI_ConfigGetCustomParam(m_handle, paramIndex, timoutMs)
    retval
  }

  /**
    * Sets a parameter. Generally this is not used.
    * This can be utilized in
    * - Using new features without updating API installation.
    * - Errata workarounds to circumvent API implementation.
    * - Allows for rapid testing / unit testing of firmware.
    *
    * @param param
    *            Parameter enumeration.
    * @param value
    *            Value of parameter.
    * @param subValue
    *            Subvalue for parameter. Maximum value of 255.
    * @param ordinal
    *            Ordinal of parameter.
    * @param timeoutMs
    *            Timeout value in ms. If nonzero, function will wait for
    *            config success and report an error if it times out.
    *            If zero, no blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def configSetParameter(param: ParamEnum,
                         value: Double,
                         subValue: Int,
                         ordinal: Int,
                         timeoutMs: Int): ErrorCode =
    configSetParameter(param.value, value, subValue, ordinal, timeoutMs)

  /**
    * Sets a parameter. Generally this is not used.
    * This can be utilized in
    * - Using new features without updating API installation.
    * - Errata workarounds to circumvent API implementation.
    * - Allows for rapid testing / unit testing of firmware.
    *
    * @param param
    *            Parameter enumeration.
    * @param value
    *            Value of parameter.
    * @param subValue
    *            Subvalue for parameter. Maximum value of 255.
    * @param ordinal
    *            Ordinal of parameter.
    * @param timeoutMs
    *            Timeout value in ms. If nonzero, function will wait for
    *            config success and report an error if it times out.
    *            If zero, no blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def configSetParameter(param: Int,
                         value: Double,
                         subValue: Int,
                         ordinal: Int,
                         timeoutMs: Int): ErrorCode = {
    val retval: Int = CANifierJNI.JNI_ConfigSetParameter(m_handle,
      param,
      value,
      subValue,
      ordinal,
      timeoutMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Gets a parameter. Generally this is not used.
    * This can be utilized in
    * - Using new features without updating API installation.
    * - Errata workarounds to circumvent API implementation.
    * - Allows for rapid testing / unit testing of firmware.
    *
    * @param param
    *            Parameter enumeration.
    * @param ordinal
    *            Ordinal of parameter.
    * @param timeoutMs
    *            Timeout value in ms. If nonzero, function will wait for
    *            config success and report an error if it times out.
    *            If zero, no blocking or checking is performed.
    * @return Value of parameter.
    */
  def configGetParameter(param: ParamEnum,
                         ordinal: Int,
                         timeoutMs: Int): Double =
    CANifierJNI.JNI_ConfigGetParameter(m_handle,
      param.value,
      ordinal,
      timeoutMs)

  /**
    * Sets the period of the given status frame.
    *
    * @param statusFrame
    *            Frame whose period is to be changed.
    * @param periodMs
    *            Period in ms for the given frame.
    * @param timeoutMs
    *            Timeout value in ms. If nonzero, function will wait for
    *            config success and report an error if it times out.
    *            If zero, no blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def setStatusFramePeriod(statusFrame: CANifierStatusFrame,
                           periodMs: Int,
                           timeoutMs: Int): ErrorCode = {
    val retval: Int = CANifierJNI.JNI_SetStatusFramePeriod(m_handle,
      statusFrame.value,
      periodMs,
      timeoutMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Sets the period of the given status frame.
    *
    * @param statusFrame
    *            Frame whose period is to be changed.
    * @param periodMs
    *            Period in ms for the given frame.
    * @param timeoutMs
    *            Timeout value in ms. If nonzero, function will wait for
    *            config success and report an error if it times out.
    *            If zero, no blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def setStatusFramePeriod(statusFrame: Int,
                           periodMs: Int,
                           timeoutMs: Int): ErrorCode = {
    val retval: Int = CANifierJNI.JNI_SetStatusFramePeriod(m_handle,
      statusFrame,
      periodMs,
      timeoutMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Gets the period of the given status frame.
    *
    * @param frame
    *            Frame to get the period of.
    * @param timeoutMs
    *            Timeout value in ms. If nonzero, function will wait for
    *            config success and report an error if it times out.
    *            If zero, no blocking or checking is performed.
    * @return Period of the given status frame.
    */
  def getStatusFramePeriod(frame: CANifierStatusFrame, timeoutMs: Int): Int =
    CANifierJNI.JNI_GetStatusFramePeriod(m_handle, frame.value, timeoutMs)

  /**
    * Sets the period of the given control frame.
    *
    * @param frame
    *            Frame whose period is to be changed.
    * @param periodMs
    *            Period in ms for the given frame.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def setControlFramePeriod(frame: CANifierControlFrame,
                            periodMs: Int): ErrorCode = {
    val retval: Int =
      CANifierJNI.JNI_SetControlFramePeriod(m_handle, frame.value, periodMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Sets the period of the given control frame.
    *
    * @param frame
    *            Frame whose period is to be changed.
    * @param periodMs
    *            Period in ms for the given frame.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def setControlFramePeriod(frame: Int, periodMs: Int): ErrorCode = {
    val retval: Int =
      CANifierJNI.JNI_SetControlFramePeriod(m_handle, frame, periodMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Gets the firmware version of the device.
    *
    * @return Firmware version of device.
    */
  def getFirmwareVersion(): Int = CANifierJNI.JNI_GetFirmwareVersion(m_handle)

  /**
    * Returns true if the device has reset since last call.
    *
    * @return Has a Device Reset Occurred?
    */
  def hasResetOccurred(): Boolean = CANifierJNI.JNI_HasResetOccurred(m_handle)

  /**
    * Gets the CANifier fault status
    *
    * @param toFill
    *            Container for fault statuses.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def getFaults(toFill: CANifierFaults): ErrorCode = {
    val bits: Int = CANifierJNI.JNI_GetFaults(m_handle)
    toFill.update(bits)
    getLastError
  }

  /**
    * Gets the CANifier sticky fault status
    *
    * @param toFill
    *            Container for sticky fault statuses.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def getStickyFaults(toFill: CANifierStickyFaults): ErrorCode = {
    val bits: Int = CANifierJNI.JNI_GetStickyFaults(m_handle)
    toFill.update(bits)
    getLastError
  }

  /**
    * Clears the Sticky Faults
    *
    * @return Error Code generated by function. 0 indicates no error.
    */
  def clearStickyFaults(timeoutMs: Int): ErrorCode = {
    val retval: Int = CANifierJNI.JNI_ClearStickyFaults(m_handle, timeoutMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Gets the bus voltage seen by the device.
    *
    * @return The bus voltage value (in volts).
    */
  def getBusVoltage(): Double = CANifierJNI.JNI_GetBusVoltage(m_handle)

}

object CANifier {
  class LEDChannel(initValue: Int) {
    val value: Int = initValue
  }

  object LEDChannel {
    val LEDChannelA: LEDChannel = new LEDChannel(0)

    val LEDChannelB: LEDChannel = new LEDChannel(1)

    val LEDChannelC: LEDChannel = new LEDChannel(2)
  }

  class PWMChannel(initValue: Int) {
    val value: Int = initValue
  }

  object PWMChannel {
    val PWMChannel0: PWMChannel = new PWMChannel(0)

    val PWMChannel1: PWMChannel = new PWMChannel(1)

    val PWMChannel2: PWMChannel = new PWMChannel(2)

    val PWMChannel3: PWMChannel = new PWMChannel(3)
  }

  class GeneralPin(initValue: Int) {
    val value: Int = initValue
  }

  object GeneralPin extends Enumeration {
    val QUAD_IDX: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.QUAD_IDX.value)

    val QUAD_B: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.QUAD_B.value)

    val QUAD_A: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.QUAD_A.value)

    val LIMR: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.LIMR.value)

    val LIMF: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.LIMF.value)

    val SDA: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.SDA.value)

    val SCL: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.SCL.value)

    val SPI_CS: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.SPI_CS.value)

    val SPI_MISO_PWM2P: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.SPI_MISO_PWM2P.value)

    val SPI_MOSI_PWM1P: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.SPI_MOSI_PWM1P.value)

    val SPI_CLK_PWM0P: GeneralPin = new GeneralPin(CANifierJNI.GeneralPin.SPI_CLK_PWM0P.value)
  }

  /**
    * Class to hold the pin values.
    */
  class PinValues {
    var QUAD_IDX: Boolean = false

    var QUAD_B: Boolean = false

    var QUAD_A: Boolean = false

    var LIMR: Boolean = false

    var LIMF: Boolean = false

    var SDA: Boolean = false

    var SCL: Boolean = false

    var SPI_CS_PWM3: Boolean = false

    var SPI_MISO_PWM2: Boolean = false

    var SPI_MOSI_PWM1: Boolean = false

    var SPI_CLK_PWM0: Boolean = false
  }
}
