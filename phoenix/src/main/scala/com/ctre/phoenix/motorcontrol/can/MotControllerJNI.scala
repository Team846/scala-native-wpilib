package com.ctre.phoenix.motorcontrol.can

import com.ctre.phoenix.CTREJNIWrapper
import com.lynbrookrobotics.scalanativejni._

@jnilib("CTRE_PhoenixCCI")
object MotControllerJNI extends CTREJNIWrapper {
  def Create(baseArbId: Int): Long = jni

  /**
    * Returns the Device ID
    *
    * @return Device number.
    */
  def GetDeviceNumber(handle: Long): Int = jni

  /**
    * Sets the demand (output) of the motor controller.
    *
    * @param mode
    * Control Mode of the Motor Controller
    * @param demand0
    * Primary Demand value
    * @param demand1
    * Secondary Demand value
    **/
  def SetDemand(handle: Long, mode: Int, demand0: Int, demand1: Int): Unit = jni

  /**
    * Sets the mode of operation during neutral throttle output.
    *
    * @param neutralMode
    * The desired mode of operation when the Controller output
    * throttle is neutral (ie brake/coast)
    **/
  def SetNeutralMode(handle: Long, neutralMode: Int): Unit = jni

  /**
    * Sets the phase of the sensor. Use when controller forward/reverse output
    * doesn't correlate to appropriate forward/reverse reading of sensor.
    *
    * @param PhaseSensor
    * Indicates whether to invert the phase of the sensor.
    **/
  def SetSensorPhase(handle: Long, PhaseSensor: Boolean): Unit = jni

  /**
    * Inverts the output of the motor controller. LEDs, sensor phase, and limit
    * switches will also be inverted to match the new forward/reverse
    * directions.
    *
    * @param invert
    * Invert state to set.
    **/
  def SetInverted(handle: Long, invert: Boolean): Unit = jni

  /**
    * Configures the open-loop ramp rate of throttle output.
    *
    * @param secondsFromNeutralToFull
    * Minimum desired time to go from neutral to full throttle. A
    * value of '0' will disable the ramp.
    * @param timeoutMs
    * Timeout value in ms. Function will generate error if config is
    * not successful within timeout.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigOpenLoopRamp(handle: Long, secondsFromNeutralToFull: Double, timeoutMs: Int): Int = jni

  /**
    * Configures the closed-loop ramp rate of throttle output.
    *
    * @param secondsFromNeutralToFull
    * Minimum desired time to go from neutral to full throttle. A
    * value of '0' will disable the ramp.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigClosedLoopRamp(handle: Long, secondsFromNeutralToFull: Double, timeoutMs: Int): Int = jni

  /**
    * Configures the forward peak output percentage.
    *
    * @param percentOut
    * Desired peak output percentage.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigPeakOutputForward(handle: Long, percentOut: Double, timeoutMs: Int): Int = jni

  /**
    * Configures the reverse peak output percentage.
    *
    * @param percentOut
    * Desired peak output percentage.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigPeakOutputReverse(handle: Long, percentOut: Double, timeoutMs: Int): Int = jni

  /**
    * Configures the forward nominal output percentage.
    *
    * @param percentOut
    * Nominal (minimum) percent output.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigNominalOutputForward(handle: Long, percentOut: Double, timeoutMs: Int): Int = jni

  /**
    * Configures the reverse nominal output percentage.
    *
    * @param percentOut
    * Nominal (minimum) percent output.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigNominalOutputReverse(handle: Long, percentOut: Double, timeoutMs: Int): Int = jni

  /**
    * Configures the output deadband percentage.
    *
    * @param percentDeadband
    * Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigNeutralDeadband(handle: Long, percentDeadband: Double, timeoutMs: Int): Int = jni

  /**
    * Configures the Voltage Compensation saturation voltage.
    *
    * @param voltage
    * TO-DO: Comment me!
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigVoltageCompSaturation(handle: Long, voltage: Double, timeoutMs: Int): Int = jni

  /**
    * Configures the voltage measurement filter.
    *
    * @param filterWindowSamples
    * Number of samples in the rolling average of voltage
    * measurement.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigVoltageMeasurementFilter(handle: Long, filterWindowSamples: Int, timeoutMs: Int): Int = jni

  /**
    * Enables voltage compensation. If enabled, voltage compensation works in
    * all control modes.
    *
    * @param enable
    * Enable state of voltage compensation.
    **/
  def EnableVoltageCompensation(handle: Long, enable: Boolean): Unit = jni

  /**
    * Gets the bus voltage seen by the motor controller.
    *
    * @return The bus voltage value (in volts).
    */
  def GetBusVoltage(handle: Long): Double = jni

  /**
    * Gets the output percentage of the motor controller.
    *
    * @return Output of the motor controller (in percent).
    */
  def GetMotorOutputPercent(handle: Long): Double = jni

  /**
    * Gets the output current of the motor controller.
    *
    * @return Output current (in amps).
    */
  def GetOutputCurrent(handle: Long): Double = jni

  /**
    * Gets the temperature of the motor controller.
    *
    * @return The temperature of the motor controller (in 'C)
    */
  def GetTemperature(handle: Long): Double = jni

  /**
    * Configures the remote feedback filter.
    *
    * @param handle
    * handle of device.
    * @param deviceID
    * ID of remote device.
    * @param remoteSensorSource
    * Type of remote sensor.
    * @param remoteOrdinal
    * Ordinal of remote source [0-1].
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigRemoteFeedbackFilter(handle: Long, deviceID: Int, remoteSensorSource: Int, remoteOrdinal: Int, timeoutMs: Int): Int = jni

  /**
    * Select the feedback device for the motor controller.
    *
    * @param feedbackDevice
    * Feedback Device to select.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigSelectedFeedbackSensor(handle: Long, feedbackDevice: Int, pidIdx: Int, timeoutMs: Int): Int = jni

  def ConfigSensorTerm(handle: Long, sensorTerm: Int, feedbackDevice: Int, timeoutMs: Int): Int = jni

  /**
    * Get the selected sensor position.
    *
    * @return Position of selected sensor (in Raw Sensor Units).
    */
  def GetSelectedSensorPosition(handle: Long, pidIdx: Int): Int = jni

  /**
    * Get the selected sensor velocity.
    *
    * @return Velocity of selected sensor (in Raw Sensor Units per 100 ms).
    */
  def GetSelectedSensorVelocity(handle: Long, pidIdx: Int): Int = jni

  /**
    * Sets the sensor position to the given value.
    *
    * @param sensorPos
    * Position to set for the selected sensor (in Raw Sensor Units).
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def SetSelectedSensorPosition(handle: Long, sensorPos: Int, pidIdx: Int, timeoutMs: Int): Int = jni

  /**
    * Sets the period of the given control frame.
    *
    * @param frame
    * Frame whose period is to be changed.
    * @param periodMs
    * Period in ms for the given frame.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def SetControlFramePeriod(handle: Long, frame: Int, periodMs: Int): Int = jni

  /**
    * Sets the period of the given status frame.
    *
    * @param frame
    * Frame whose period is to be changed.
    * @param periodMs
    * Period in ms for the given frame.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def SetStatusFramePeriod(handle: Long, frame: Int, periodMs: Int, timeoutMs: Int): Int = jni

  /**
    * Gets the period of the given status frame.
    *
    * @param frame
    * Frame to get the period of.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return The period of the given status frame.
    */
  def GetStatusFramePeriod(handle: Long, frame: Int, timeoutMs: Int): Int = jni

  /**
    * Sets the period over which velocity measurements are taken.
    *
    * @param period
    * Desired period for the velocity measurement. @see
    * #VelocityMeasPeriod
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigVelocityMeasurementPeriod(handle: Long, period: Int, timeoutMs: Int): Int = jni

  /**
    * Sets the number of velocity samples used in the rolling average velocity
    * measurement.
    *
    * @param windowSize
    * Number of samples in the rolling average of velocity
    * measurement.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigVelocityMeasurementWindow(handle: Long, windowSize: Int, timeoutMs: Int): Int = jni

  /**
    * Configures the forward limit switch for a remote source.
    *
    * @param type
    * Remote limit switch source. @see #LimitSwitchSource
    * @param normalOpenOrClose
    * Setting for normally open or normally closed.
    * @param deviceID
    * Device ID of remote source.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigForwardLimitSwitchSource(handle: Long, `type`: Int, normalOpenOrClose: Int, deviceID: Int, timeoutMs: Int): Int = jni

  /**
    * Configures the reverse limit switch for a remote source.
    *
    * @param type
    * Remote limit switch source. @see #LimitSwitchSource
    * @param normalOpenOrClose
    * Setting for normally open or normally closed.
    * @param deviceID
    * Device ID of remote source.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigReverseLimitSwitchSource(handle: Long, `type`: Int, normalOpenOrClose: Int, deviceID: Int, timeoutMs: Int): Int = jni

  /**
    * Sets the enable state for limit switches.
    *
    * @param enable
    * Enable state for limit switches.
    **/
  def OverrideLimitSwitchesEnable(handle: Long, enable: Boolean): Unit = jni

  /**
    * Configures the forward soft limit.
    *
    * @param forwardSensorLimit
    * Forward Sensor Position Limit (in Raw Sensor Units).
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigForwardSoftLimitThreshold(handle: Long, forwardSensorLimit: Int, timeoutMs: Int): Int = jni

  /**
    * Configures the reverse soft limit.
    *
    * @param reverseSensorLimit
    * Reverse Sensor Position Limit (in Raw Sensor Units).
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigReverseSoftLimitThreshold(handle: Long, reverseSensorLimit: Int, timeoutMs: Int): Int = jni

  def ConfigForwardSoftLimitEnable(handle: Long, enable: Boolean, timeoutMs: Int): Int = jni

  def ConfigReverseSoftLimitEnable(handle: Long, enable: Boolean, timeoutMs: Int): Int = jni

  /**
    * Sets the enable state for soft limit switches.
    *
    * @param enable
    * Enable state for soft limit switches.
    **/
  def OverrideSoftLimitsEnable(handle: Long, enable: Boolean): Unit = jni

  /**
    * Sets the 'P' constant in the given parameter slot.
    *
    * @param slotIdx
    * Parameter slot for the constant.
    * @param value
    * Value of the P constant.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def Config_kP(handle: Long, slotIdx: Int, value: Double, timeoutMs: Int): Int = jni

  /**
    * Sets the 'I' constant in the given parameter slot.
    *
    * @param slotIdx
    * Parameter slot for the constant.
    * @param value
    * Value of the I constant.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def Config_kI(handle: Long, slotIdx: Int, value: Double, timeoutMs: Int): Int = jni

  /**
    * Sets the 'D' constant in the given parameter slot.
    *
    * @param slotIdx
    * Parameter slot for the constant.
    * @param value
    * Value of the D constant.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def Config_kD(handle: Long, slotIdx: Int, value: Double, timeoutMs: Int): Int = jni

  /**
    * Sets the 'F' constant in the given parameter slot.
    *
    * @param slotIdx
    * Parameter slot for the constant.
    * @param value
    * Value of the F constant.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def Config_kF(handle: Long, slotIdx: Int, value: Double, timeoutMs: Int): Int = jni

  /**
    * Sets the Integral Zone constant in the given parameter slot.
    *
    * @param slotIdx
    * Parameter slot for the constant.
    * @param izone
    * Value of the Integral Zone constant.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def Config_IntegralZone(handle: Long, slotIdx: Int, izone: Double, timeoutMs: Int): Int = jni

  /**
    * Sets the allowable closed-loop error in the given parameter slot.
    *
    * @param slotIdx
    * Parameter slot for the constant.
    * @param allowableClosedLoopError
    * Value of the allowable closed-loop error.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigAllowableClosedloopError(handle: Long, slotIdx: Int, allowableClosedLoopError: Int, timeoutMs: Int): Int = jni

  /**
    * Sets the maximum integral accumulator in the given parameter slot.
    *
    * @param slotIdx
    * Parameter slot for the constant.
    * @param iaccum
    * Value of the maximum integral accumulator.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigMaxIntegralAccumulator(handle: Long, slotIdx: Int, iaccum: Double, timeoutMs: Int): Int = jni

  /**
    * Sets the integral accumulator.
    *
    * @param iaccum
    * Value to set for the integral accumulator.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @param pidIdx
    * Which closed loop to manipulate. 0 for primary, 1 for cascaded
    * secondary loop.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def SetIntegralAccumulator(handle: Long, iaccum: Double, pidIdx: Int, timeoutMs: Int): Int = jni

  /**
    * Gets the closed-loop error.
    *
    * @param pidIdx
    * Which closed loop to manipulate. 0 for primary, 1 for cascaded
    * secondary loop.
    * @return Closed-loop error value.
    */
  def GetClosedLoopError(handle: Long, pidIdx: Int): Int = jni

  /**
    * Gets the iaccum value.
    *
    * @param pidIdx
    * Which closed loop to manipulate. 0 for primary, 1 for cascaded
    * secondary loop.
    * @return Integral accumulator value.
    */
  def GetIntegralAccumulator(handle: Long, pidIdx: Int): Double = jni

  /**
    * Gets the derivative of the closed-loop error.
    *
    * @param pidIdx
    * Which closed loop to manipulate. 0 for primary, 1 for cascaded
    * secondary loop.
    * @return Error derivative value.
    */
  def GetErrorDerivative(handle: Long, pidIdx: Int): Double = jni

  /**
    * Selects which profile slot to use for closed-loop control.
    *
    * @param slotIdx
    * Profile slot to select.
    * @param pidIdx
    * Which closed loop to manipulate. 0 for primary, 1 for cascaded
    * secondary loop.
    **/
  def SelectProfileSlot(handle: Long, slotIdx: Int, pidIdx: Int): Unit = jni

  def GetActiveTrajectoryPosition(handle: Long): Int = jni

  def GetActiveTrajectoryVelocity(handle: Long): Int = jni

  def GetActiveTrajectoryHeading(handle: Long): Double = jni

  /**
    * Sets the Motion Magic Cruise Velocity.
    *
    * @param sensorUnitsPer100ms
    * Motion Magic Cruise Velocity (in Raw Sensor Units per 100 ms).
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigMotionCruiseVelocity(handle: Long, sensorUnitsPer100ms: Int, timeoutMs: Int): Int = jni

  /**
    * Sets the Motion Magic Acceleration.
    *
    * @param sensorUnitsPer100msPerSec
    * Motion Magic Acceleration (in Raw Sensor Units per 100 ms per
    * second).
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigMotionAcceleration(handle: Long, sensorUnitsPer100msPerSec: Int, timeoutMs: Int): Int = jni

  def ClearMotionProfileTrajectories(handle: Long): Int = jni

  def GetMotionProfileTopLevelBufferCount(handle: Long): Int = jni

  def PushMotionProfileTrajectory(handle: Long, position: Double, velocity: Double, headingDeg: Double, profileSlotSelect: Int, isLastPoint: Boolean, zeroPos: Boolean): Int = jni

  def PushMotionProfileTrajectory2(handle: Long, position: Double, velocity: Double, headingDeg: Double, profileSlotSelect0: Int, profileSlotSelect1: Int, isLastPoint: Boolean, zeroPos: Boolean, durationMs: Int): Int = jni

  def IsMotionProfileTopLevelBufferFull(handle: Long): Boolean = jni

  def ProcessMotionProfileBuffer(handle: Long): Int = jni

  def GetMotionProfileStatus(handle: Long, toFill_9: Array[Int]): Int = jni

  def GetMotionProfileStatus2(handle: Long, toFill_11: Array[Int]): Int = jni

  def ClearMotionProfileHasUnderrun(handle: Long, timeoutMs: Int): Int = jni

  def ChangeMotionControlFramePeriod(handle: Long, periodMs: Int): Int = jni

  def ConfigMotionProfileTrajectoryPeriod(handle: Long, periodMs: Int, timeoutMs: Int): Int = jni

  /**
    * Gets the last error generated by this object.
    *
    * @return Last Error Code generated by a function.
    */
  def GetLastError(handle: Long): Int = jni

  /**
    * Gets the firmware version of the device.
    *
    * @return Firmware version of device.
    */
  def GetFirmwareVersion(handle: Long): Int = jni

  /**
    * Returns true if the device has reset.
    *
    * @return Has a Device Reset Occurred?
    */
  def HasResetOccurred(handle: Long): Boolean = jni

  /**
    * Sets the value of a custom parameter.
    *
    * @param newValue
    * Value for custom parameter.
    * @param paramIndex
    * Index of custom parameter.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigSetCustomParam(handle: Long, newValue: Int, paramIndex: Int, timeoutMs: Int): Int = jni

  /**
    * Gets the value of a custom parameter.
    *
    * @param paramIndex
    * Index of custom parameter.
    * @param timoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Value of the custom param.
    */
  def ConfigGetCustomParam(handle: Long, paramIndex: Int, timoutMs: Int): Int = jni

  /**
    * Sets a parameter.
    *
    * @param param
    * Parameter enumeration.
    * @param value
    * Value of parameter.
    * @param subValue
    * Subvalue for parameter. Maximum value of 255.
    * @param ordinal
    * Ordinal of parameter.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigSetParameter(handle: Long, param: Int, value: Double, subValue: Int, ordinal: Int, timeoutMs: Int): Int = jni

  /**
    * Gets a parameter.
    *
    * @param param
    * Parameter enumeration.
    * @param ordinal
    * Ordinal of parameter.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Value of parameter.
    */
  def ConfigGetParameter(handle: Long, param: Int, ordinal: Int, timeoutMs: Int): Double = jni

  /**
    * Configures the peak current limit of the motor controller.
    *
    * @param amps
    * Peak current limit (in amps).
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigPeakCurrentLimit(handle: Long, amps: Int, timeoutMs: Int): Int = jni

  /**
    * Configures the maximum time allowed at peak current limit of the motor
    * controller.
    *
    * @param milliseconds
    * Maximum time allowed at peak current limit (in milliseconds).
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigPeakCurrentDuration(handle: Long, milliseconds: Int, timeoutMs: Int): Int = jni

  /**
    * Configures the continuous current limit.
    *
    * @param amps
    * Continuous Current Limit.
    * @param timeoutMs
    * Timeout value in ms. @see #ConfigOpenLoopRamp
    * @return Error Code generated by function. 0 indicates no error.
    */
  def ConfigContinuousCurrentLimit(handle: Long, amps: Int, timeoutMs: Int): Int = jni

  /**
    * Enables the current limit feature.
    *
    * @param enable
    * Enable state of current limit.
    **/
  def EnableCurrentLimit(handle: Long, enable: Boolean): Int = jni

  def GetAnalogIn(handle: Long): Int = jni

  def SetAnalogPosition(handle: Long, newPosition: Int, timeoutMs: Int): Int = jni

  def GetAnalogInRaw(handle: Long): Int = jni

  def GetAnalogInVel(handle: Long): Int = jni

  def GetQuadraturePosition(handle: Long): Int = jni

  def SetQuadraturePosition(handle: Long, newPosition: Int, timeoutMs: Int): Int = jni

  def GetQuadratureVelocity(handle: Long): Int = jni

  def GetPulseWidthPosition(handle: Long): Int = jni

  def SetPulseWidthPosition(handle: Long, newPosition: Int, timeoutMs: Int): Int = jni

  def GetPulseWidthVelocity(handle: Long): Int = jni

  def GetPulseWidthRiseToFallUs(handle: Long): Int = jni

  def GetPulseWidthRiseToRiseUs(handle: Long): Int = jni

  def GetPinStateQuadA(handle: Long): Int = jni

  def GetPinStateQuadB(handle: Long): Int = jni

  def GetPinStateQuadIdx(handle: Long): Int = jni

  def IsFwdLimitSwitchClosed(handle: Long): Int = jni

  def IsRevLimitSwitchClosed(handle: Long): Int = jni

  def GetFaults(handle: Long): Int = jni

  def GetStickyFaults(handle: Long): Int = jni

  def ClearStickyFaults(handle: Long, timeoutMs: Int): Int = jni

  def SelectDemandType(handle: Long, enable: Int): Int = jni

  def SetMPEOutput(handle: Long, mpeOutput: Int): Int = jni

  def EnableHeadingHold(handle: Long, enable: Int): Int = jni

  def GetClosedLoopTarget(handle: Long, pidIdx: Int): Int = jni
}
