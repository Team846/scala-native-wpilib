package com.ctre.phoenix.motorcontrol.can

import com.ctre.phoenix.ErrorCode
import com.ctre.phoenix.motorcontrol.IMotorControllerEnhanced
import com.ctre.phoenix.motorcontrol.LimitSwitchNormal
import com.ctre.phoenix.motorcontrol.LimitSwitchSource
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced
import com.ctre.phoenix.motorcontrol.VelocityMeasPeriod
import com.ctre.phoenix.motorcontrol.can.MotControllerJNI

import edu.wpi.first.wpilibj.hal.FRCNetComm.tResourceType
import edu.wpi.first.wpilibj.hal.HAL

/**
  * CTRE Talon SRX Motor Controller when used on CAN Bus.
  */
class TalonSRX(val deviceNumber: Int) extends BaseMotorController(deviceNumber | 0x02040000) with IMotorControllerEnhanced {
  HAL.report(tResourceType.kResourceType_CANTalonSRX, deviceNumber + 1)

  /**
    * Sets the period of the given status frame.
    *
    * User ensure CAN Bus utilization is not high.
    *
    * This setting is not persistent and is lost when device is reset.
    * If this is a concern, calling application can use HasReset()
    * to determine if the status frame needs to be reconfigured.
    *
    * @param frame
    * Frame whose period is to be changed.
    * @param periodMs
    * Period in ms for the given frame.
    * @param timeoutMs
    * Timeout value in ms. If nonzero, function will wait for
    * config success and report an error if it times out.
    * If zero, no blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def setStatusFramePeriod(frame: StatusFrameEnhanced, periodMs: Int, timeoutMs: Int): ErrorCode = super.setStatusFramePeriod(frame.value, periodMs, timeoutMs)

  /**
    * Gets the period of the given status frame.
    *
    * @param frame
    * Frame to get the period of.
    * @param timeoutMs
    * Timeout value in ms. If nonzero, function will wait for
    * config success and report an error if it times out.
    * If zero, no blocking or checking is performed.
    * @return Period of the given status frame.
    */
  override def getStatusFramePeriod(frame: StatusFrameEnhanced, timeoutMs: Int): Int = super.getStatusFramePeriod(frame, timeoutMs)

  /**
    * Configures the period of each velocity sample.
    * Every 1ms a position value is sampled, and the delta between that sample
    * and the position sampled kPeriod ms ago is inserted into a filter.
    * kPeriod is configured with this function.
    *
    * @param period
    * Desired period for the velocity measurement. @see
    * #VelocityMeasPeriod
    * @param timeoutMs
    * Timeout value in ms. If nonzero, function will wait for
    * config success and report an error if it times out.
    * If zero, no blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  override def configVelocityMeasurementPeriod(period: VelocityMeasPeriod, timeoutMs: Int): ErrorCode = super.configVelocityMeasurementPeriod(period, timeoutMs)

  /**
    * Sets the number of velocity samples used in the rolling average velocity
    * measurement.
    *
    * @param windowSize
    *            Number of samples in the rolling average of velocity
    *            measurement. Valid values are 1,2,4,8,16,32. If another
    *            value is specified, it will truncate to nearest support value.
    * @param timeoutMs
    *            Timeout value in ms. If nonzero, function will wait for
    *            config success and report an error if it times out.
    *            If zero, no blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  override def configVelocityMeasurementWindow(windowSize: Int, timeoutMs: Int): ErrorCode = super.configVelocityMeasurementWindow(windowSize, timeoutMs)

  /**
    * Configures a limit switch for a local/remote source.
    *
    * For example, a CAN motor controller may need to monitor the Limit-R pin
    * of another Talon, CANifier, or local Gadgeteer feedback connector.
    *
    * If the sensor is remote, a device ID of zero is assumed.
    * If that's not desired, use the four parameter version of this function.
    *
    * @param type
    * Limit switch source.
    * User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature.
    * @param normalOpenOrClose
    * Setting for normally open, normally closed, or disabled. This setting
    * matches the web-based configuration drop down.
    * @param timeoutMs
    * Timeout value in ms. If nonzero, function will wait for
    * config success and report an error if it times out.
    * If zero, no blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  override def configForwardLimitSwitchSource(`type`: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: Int): ErrorCode = super.configForwardLimitSwitchSource(`type`.value, normalOpenOrClose.value, 0x00000000, timeoutMs)

  /**
    * Configures a limit switch for a local/remote source.
    *
    * For example, a CAN motor controller may need to monitor the Limit-R pin
    * of another Talon, CANifier, or local Gadgeteer feedback connector.
    *
    * If the sensor is remote, a device ID of zero is assumed. If that's not
    * desired, use the four parameter version of this function.
    *
    * @param type
    * Limit switch source. @see #LimitSwitchSource User can choose
    * between the feedback connector, remote Talon SRX, CANifier, or
    * deactivate the feature.
    * @param normalOpenOrClose
    * Setting for normally open, normally closed, or disabled. This
    * setting matches the web-based configuration drop down.
    * @param timeoutMs
    * Timeout value in ms. If nonzero, function will wait for config
    * success and report an error if it times out. If zero, no
    * blocking or checking is performed.
    * @return Error Code generated by function. 0 indicates no error.
    */
  def configReverseLimitSwitchSource(`type`: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: Int): ErrorCode = super.configReverseLimitSwitchSource(`type`.value, normalOpenOrClose.value, 0x00000000, timeoutMs)

  /**
    * Configure the peak allowable current (when current limit is enabled).
    *
    * Current limit is activated when current exceeds the peak limit for longer
    * than the peak duration. Then software will limit to the continuous limit.
    * This ensures current limiting while allowing for momentary excess current
    * events.
    *
    * For simpler current-limiting (single threshold) use
    * ConfigContinuousCurrentLimit() and set the peak to zero:
    * ConfigPeakCurrentLimit(0).
    *
    * @param amps
    * Amperes to limit.
    * @param timeoutMs
    * Timeout value in ms. If nonzero, function will wait for config
    * success and report an error if it times out. If zero, no
    * blocking or checking is performed.
    */
  def configPeakCurrentLimit(amps: Int, timeoutMs: Int): ErrorCode = {
    val retval = MotControllerJNI.ConfigPeakCurrentLimit(m_handle, amps, timeoutMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Configure the peak allowable duration (when current limit is enabled).
    *
    * Current limit is activated when current exceeds the peak limit for longer
    * than the peak duration. Then software will limit to the continuous limit.
    * This ensures current limiting while allowing for momentary excess current
    * events.
    *
    * For simpler current-limiting (single threshold) use
    * ConfigContinuousCurrentLimit() and set the peak to zero:
    * ConfigPeakCurrentLimit(0).
    *
    * @param milliseconds
    * How long to allow current-draw past peak limit.
    * @param timeoutMs
    * Timeout value in ms. If nonzero, function will wait for config
    * success and report an error if it times out. If zero, no
    * blocking or checking is performed.
    */
  def configPeakCurrentDuration(milliseconds: Int, timeoutMs: Int): ErrorCode = {
    val retval = MotControllerJNI.ConfigPeakCurrentDuration(m_handle, milliseconds, timeoutMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Configure the continuous allowable current-draw (when current limit is
    * enabled).
    *
    * Current limit is activated when current exceeds the peak limit for longer
    * than the peak duration. Then software will limit to the continuous limit.
    * This ensures current limiting while allowing for momentary excess current
    * events.
    *
    * For simpler current-limiting (single threshold) use
    * ConfigContinuousCurrentLimit() and set the peak to zero:
    * ConfigPeakCurrentLimit(0).
    *
    * @param amps
    * Amperes to limit.
    * @param timeoutMs
    * Timeout value in ms. If nonzero, function will wait for config
    * success and report an error if it times out. If zero, no
    * blocking or checking is performed.
    */
  def configContinuousCurrentLimit(amps: Int, timeoutMs: Int): ErrorCode = {
    val retval = MotControllerJNI.ConfigContinuousCurrentLimit(m_handle, amps, timeoutMs)
    ErrorCode.valueOf(retval)
  }

  /**
    * Enable or disable Current Limit.
    *
    * @param enable
    * Enable state of current limit.
    * @see ConfigPeakCurrentLimit, ConfigPeakCurrentDuration,
    *      ConfigContinuousCurrentLimit
    */
  def enableCurrentLimit(enable: Boolean): Unit = MotControllerJNI.EnableCurrentLimit(m_handle, enable)
}
